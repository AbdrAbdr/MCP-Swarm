/**
 * MCP Swarm v0.9.17 - Smart Tools: infra
 * Auto-generated from smartTools.ts
 */

import { z } from "zod";

import { predictConflicts, analyzeConflictHistory, getConflictHotspots, recordConflictEvent } from "../workflows/conflictPrediction.js";
import { shareScreenshot, listScreenshots } from "../workflows/screenshot.js";
import { requestPlatformCheck, respondToPlatformCheck, getPendingPlatformChecks } from "../workflows/crossPlatform.js";
import { archiveFinding, searchKnowledge } from "../workflows/knowledgeBase.js";
import { triggerUrgentPreemption, resolveUrgent, getActiveUrgent } from "../workflows/preemption.js";
import { requestCollectiveAdvice, provideAdvice, getOpenAdviceRequests } from "../workflows/collectiveAdvice.js";
import { recordFileEdit, findBestAgent, getExpertiseMap, predictAffectedPaths, autoAssignTask } from "../workflows/smartRouting.js";
import { createReviewRequest, assignReviewer, addReviewComment, completeReview, resolveComment, getReviewsForReviewer, getReviewsForAuthor, getPendingReviews, getReviewStats } from "../workflows/autoReview.js";
import { enableGitHubSync, enableLinearSync, syncFromGitHub, syncFromLinear, syncAll, exportTaskToGitHub, exportTaskToLinear, getSyncStatus, createGitHubIssue, closeGitHubIssue, addGitHubComment } from "../workflows/externalSync.js";
import { handleTelegramTool } from "../integrations/telegram.js";
import { autoGenerateDocs } from "../workflows/autoDocumentation.js";
import { generateTaskDocumentation, listDocumentation, getDocumentation } from "../workflows/autoDocumentation.js";
import { trackExpertise } from "../workflows/specialization.js";
import { recordAgentEdit, suggestAgentForTask as suggestAgentAdvanced, getTopExperts, listAllAgentExpertise } from "../workflows/smartRouting.js";
import { generateTimeline, getTimelineVisualization } from "../workflows/timeline.js";
import { checkAgentHealth, getDeadAgents, forceReassignTask, getSwarmHealthSummary } from "../workflows/agentHealth.js";
import { startSessionRecording, logSessionAction, stopSessionRecording, listSessionRecordings, replaySession } from "../workflows/sessionRecording.js";
import { startQALoop, runQAIteration, logQAFix, getQALoop, listQALoops, getQAFixSuggestions, generateQAReport } from "../workflows/qaLoop.js";
import { initToolClusters, listToolClusters, getClusterTools, findToolCluster, addToolToCluster, createToolCluster, getToolClusterSummary } from "../workflows/toolClusters.js";

// Helper to wrap results
function wrapResult(result: any) {
  return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }], structuredContent: result };
}


/**
 * 45. swarm_external - GitHub/Linear sync
 */
export const swarmExternalTool = [
  "swarm_external",
  {
    title: "Swarm External",
    description: "GitHub and Linear.app sync. Actions: enable_github, enable_linear, sync_github, sync_linear, sync_all, export_github, export_linear, status, create_issue, close_issue, comment",
    inputSchema: z.object({
      action: z.enum(["enable_github", "enable_linear", "sync_github", "sync_linear", "sync_all", "export_github", "export_linear", "status", "create_issue", "close_issue", "comment"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // GitHub enable
      owner: z.string().optional().describe("GitHub owner"),
      repo: z.string().optional().describe("GitHub repo"),
      labelFilter: z.array(z.string()).optional().describe("Label filter"),
      autoImport: z.boolean().optional().describe("Auto import issues"),
      autoClose: z.boolean().optional().describe("Auto close on done"),
      // Linear enable
      teamId: z.string().optional().describe("Linear team ID"),
      projectId: z.string().optional().describe("Linear project ID"),
      // Export
      taskId: z.string().optional().describe("Task ID (for export)"),
      // Issue operations
      issueNumber: z.string().optional().describe("Issue number"),
      title: z.string().optional().describe("Issue title"),
      body: z.string().optional().describe("Issue body"),
      labels: z.array(z.string()).optional().describe("Labels"),
      comment: z.string().optional().describe("Comment text"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      case "enable_github":
        return wrapResult(await enableGitHubSync(repoPath, input.owner, input.repo, {
          labelFilter: input.labelFilter,
          autoImport: input.autoImport,
          autoClose: input.autoClose,
        }));
      case "enable_linear":
        return wrapResult(await enableLinearSync(repoPath, input.teamId, {
          projectId: input.projectId,
          autoImport: input.autoImport,
          autoClose: input.autoClose,
        }));
      case "sync_github":
        return wrapResult(await syncFromGitHub(repoPath));
      case "sync_linear":
        return wrapResult(await syncFromLinear(repoPath));
      case "sync_all":
        return wrapResult(await syncAll(repoPath));
      case "export_github":
        return wrapResult(await exportTaskToGitHub(repoPath, input.taskId));
      case "export_linear":
        return wrapResult(await exportTaskToLinear(repoPath, input.taskId));
      case "status":
        return wrapResult(await getSyncStatus(repoPath));
      case "create_issue":
        return wrapResult(await createGitHubIssue(repoPath, input.title, input.body, input.labels));
      case "close_issue":
        return wrapResult(await closeGitHubIssue(repoPath, input.issueNumber, input.comment));
      case "comment":
        return wrapResult(await addGitHubComment(repoPath, input.issueNumber, input.comment));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 30. swarm_platform - Cross-platform checks
 */
export const swarmPlatformTool = [
  "swarm_platform",
  {
    title: "Swarm Platform",
    description: "Cross-platform checks. Actions: request, respond, list",
    inputSchema: z.object({
      action: z.enum(["request", "respond", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      fromAgent: z.string().optional().describe("From agent (for request)"),
      targetPlatforms: z.array(z.string()).optional().describe("Target platforms (for request)"),
      component: z.string().optional().describe("Component (for request)"),
      description: z.string().optional().describe("Description (for request)"),
      screenshotBase64: z.string().optional().describe("Screenshot base64 (for request, respond)"),
      checkId: z.string().optional().describe("Check ID (for respond)"),
      agent: z.string().optional().describe("Agent (for respond)"),
      result: z.enum(["pass", "fail"]).optional().describe("Result (for respond)"),
      issueDescription: z.string().optional().describe("Issue description (for respond)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "request":
        return wrapResult(await requestPlatformCheck({
          repoPath: input.repoPath,
          fromAgent: input.fromAgent,
          targetPlatforms: input.targetPlatforms,
          component: input.component,
          description: input.description,
          screenshotBase64: input.screenshotBase64,
          commitMode: input.commitMode || "push",
        }));
      case "respond":
        return wrapResult(await respondToPlatformCheck({
          repoPath: input.repoPath,
          checkId: input.checkId,
          agent: input.agent,
          result: input.result,
          issueDescription: input.issueDescription,
          screenshotBase64: input.screenshotBase64,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await getPendingPlatformChecks(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 39. swarm_preemption - Urgent task preemption
 */
export const swarmPreemptionTool = [
  "swarm_preemption",
  {
    title: "Swarm Preemption",
    description: "Urgent task preemption. Actions: trigger, resolve, active",
    inputSchema: z.object({
      action: z.enum(["trigger", "resolve", "active"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for trigger)"),
      title: z.string().optional().describe("Title (for trigger)"),
      reason: z.string().optional().describe("Reason (for trigger)"),
      initiator: z.string().optional().describe("Initiator (for trigger)"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files (for trigger)"),
      urgentId: z.string().optional().describe("Urgent ID (for resolve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "trigger":
        return wrapResult(await triggerUrgentPreemption({
          repoPath: input.repoPath,
          taskId: input.taskId,
          title: input.title,
          reason: input.reason,
          initiator: input.initiator,
          affectedFiles: input.affectedFiles || [],
          commitMode: input.commitMode || "push",
        }));
      case "resolve":
        return wrapResult(await resolveUrgent({
          repoPath: input.repoPath,
          urgentId: input.urgentId,
          commitMode: input.commitMode || "push",
        }));
      case "active":
        return wrapResult(await getActiveUrgent(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 34. swarm_expertise - Agent expertise tracking
 */
export const swarmExpertiseTool = [
  "swarm_expertise",
  {
    title: "Swarm Expertise",
    description: "Agent expertise tracking. Actions: track, suggest, record, experts, list",
    inputSchema: z.object({
      action: z.enum(["track", "suggest", "record", "experts", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      filesEdited: z.array(z.string()).optional().describe("Files edited (for track, record)"),
      files: z.array(z.string()).optional().describe("Files (for record, suggest)"),
      taskDescription: z.string().optional().describe("Task description (for suggest)"),
      filesLikelyInvolved: z.array(z.string()).optional().describe("Files likely involved (for suggest)"),
      directories: z.array(z.string()).optional().describe("Directories (for suggest)"),
      keywords: z.array(z.string()).optional().describe("Keywords (for suggest, record)"),
      taskKeywords: z.array(z.string()).optional().describe("Task keywords (for record)"),
      area: z.string().optional().describe("Area (for experts)"),
      limit: z.number().optional().describe("Limit (for experts)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "track":
        return wrapResult(await trackExpertise({
          repoPath: input.repoPath,
          agent: input.agent,
          filesEdited: input.filesEdited || [],
          commitMode: input.commitMode || "push",
        }));
      case "suggest":
        return wrapResult(await suggestAgentAdvanced({
          repoPath: input.repoPath,
          taskDescription: input.taskDescription || "",
          files: input.files,
          directories: input.directories,
          keywords: input.keywords,
        }));
      case "record":
        return wrapResult(await recordAgentEdit({
          repoPath: input.repoPath,
          agent: input.agent,
          filesEdited: input.files || input.filesEdited || [],
          taskKeywords: input.taskKeywords || input.keywords,
        }));
      case "experts":
        return wrapResult(await getTopExperts({
          repoPath: input.repoPath,
          area: input.area,
          limit: input.limit,
        }));
      case "list":
        return wrapResult(await listAllAgentExpertise({ repoPath: input.repoPath }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ NEW SMART TOOLS 42-46 (v0.9.3) ============

/**
 * 42. swarm_routing - Smart task routing based on file expertise
 */
export const swarmRoutingTool = [
  "swarm_routing",
  {
    title: "Swarm Routing",
    description: "Smart task routing based on file expertise. Actions: record, find_agent, expertise, predict, auto_assign",
    inputSchema: z.object({
      action: z.enum(["record", "find_agent", "expertise", "predict", "auto_assign"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID"),
      filePath: z.string().optional().describe("File path (for record)"),
      filePaths: z.array(z.string()).optional().describe("File paths (for find_agent)"),
      excludeBusy: z.boolean().optional().describe("Exclude busy agents (for find_agent)"),
      taskDescription: z.string().optional().describe("Task description (for predict, auto_assign)"),
      taskId: z.string().optional().describe("Task ID (for auto_assign)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "record":
        return wrapResult(await recordFileEdit({
          repoPath: input.repoPath,
          agentName: input.agentId,
          filePath: input.filePath,
        }));
      case "find_agent":
        return wrapResult(await findBestAgent({
          repoPath: input.repoPath,
          affectedPaths: input.filePaths || [],
          excludeAgents: input.excludeBusy ? [] : undefined,
        }));
      case "expertise":
        return wrapResult(await getExpertiseMap({ repoPath: input.repoPath }));
      case "predict":
        return wrapResult(predictAffectedPaths(input.taskDescription || ""));
      case "auto_assign":
        return wrapResult(await autoAssignTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskDescription || "",
          taskDescription: input.taskDescription || "",
          availableAgents: [],
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 17. swarm_knowledge - Knowledge base management
 */
export const swarmKnowledgeTool = [
  "swarm_knowledge",
  {
    title: "Swarm Knowledge",
    description: "Knowledge base management. Actions: archive, search",
    inputSchema: z.object({
      action: z.enum(["archive", "search"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for archive)"),
      category: z.enum(["bug", "workaround", "pattern", "config", "dependency", "architecture", "other"]).optional().describe("Category"),
      title: z.string().optional().describe("Title (for archive)"),
      description: z.string().optional().describe("Description (for archive)"),
      solution: z.string().optional().describe("Solution (for archive)"),
      relatedFiles: z.array(z.string()).optional().describe("Related files (for archive)"),
      tags: z.array(z.string()).optional().describe("Tags"),
      query: z.string().optional().describe("Search query (for search)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "archive":
        return wrapResult(await archiveFinding({
          repoPath: input.repoPath,
          agent: input.agent,
          category: input.category || "other",
          title: input.title,
          description: input.description,
          solution: input.solution,
          relatedFiles: input.relatedFiles,
          tags: input.tags,
          commitMode: input.commitMode || "push",
        }));
      case "search":
        return wrapResult(await searchKnowledge({
          repoPath: input.repoPath,
          query: input.query,
          category: input.category,
          tags: input.tags,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ SMART TOOLS 28-41 ============

/**
 * 28. swarm_screenshot - Screenshot sharing
 */
export const swarmScreenshotTool = [
  "swarm_screenshot",
  {
    title: "Swarm Screenshot",
    description: "Screenshot sharing. Actions: share, list",
    inputSchema: z.object({
      action: z.enum(["share", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for share)"),
      imageBase64: z.string().optional().describe("Image base64 (for share)"),
      description: z.string().optional().describe("Description (for share)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "share":
        return wrapResult(await shareScreenshot({
          repoPath: input.repoPath,
          agent: input.agent,
          imageBase64: input.imageBase64,
          description: input.description,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listScreenshots(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 41. swarm_session - Session recording
 */
export const swarmSessionTool = [
  "swarm_session",
  {
    title: "Swarm Session",
    description: "Session recording. Actions: start, log, stop, list, replay",
    inputSchema: z.object({
      action: z.enum(["start", "log", "stop", "list", "replay"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID (for start)"),
      sessionId: z.string().optional().describe("Session ID"),
      actionType: z.string().optional().describe("Action type (for log)"),
      tool: z.string().optional().describe("Tool (for log)"),
      file: z.string().optional().describe("File (for log)"),
      inputData: z.any().optional().describe("Input data (for log)"),
      outputData: z.any().optional().describe("Output data (for log)"),
      duration: z.number().optional().describe("Duration ms (for log)"),
      error: z.string().optional().describe("Error (for log)"),
      summary: z.string().optional().describe("Summary (for stop)"),
      limit: z.number().optional().describe("Limit (for list)"),
      fromIndex: z.number().optional().describe("From index (for replay)"),
      toIndex: z.number().optional().describe("To index (for replay)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startSessionRecording({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
        }));
      case "log":
        return wrapResult(await logSessionAction({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          actionType: input.actionType,
          tool: input.tool,
          file: input.file,
          inputData: input.inputData,
          outputData: input.outputData,
          duration: input.duration,
          error: input.error,
        }));
      case "stop":
        return wrapResult(await stopSessionRecording({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          summary: input.summary,
        }));
      case "list":
        return wrapResult(await listSessionRecordings({
          repoPath: input.repoPath,
          agent: input.agent,
          limit: input.limit,
        }));
      case "replay":
        return wrapResult(await replaySession({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          fromIndex: input.fromIndex,
          toIndex: input.toIndex,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ NEW SMART TOOLS 42-46 (v0.9.3) ============

/**
 * 36. swarm_timeline - Event timeline
 */
export const swarmTimelineTool = [
  "swarm_timeline",
  {
    title: "Swarm Timeline",
    description: "Event timeline. Actions: generate, visualize",
    inputSchema: z.object({
      action: z.enum(["generate", "visualize"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      since: z.string().optional().describe("Since timestamp (for generate)"),
      limit: z.number().optional().describe("Limit (for generate)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "generate":
        return wrapResult(await generateTimeline({
          repoPath: input.repoPath,
          since: input.since,
          limit: input.limit,
        }));
      case "visualize":
        return wrapResult(await getTimelineVisualization(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 40. swarm_clusters - Tool clusters
 */
export const swarmClustersTool = [
  "swarm_clusters",
  {
    title: "Swarm Clusters",
    description: "Tool clusters. Actions: init, list, tools, find, add, create, summary",
    inputSchema: z.object({
      action: z.enum(["init", "list", "tools", "find", "add", "create", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      clusterId: z.string().optional().describe("Cluster ID (for tools, add)"),
      toolName: z.string().optional().describe("Tool name (for find, add)"),
      id: z.string().optional().describe("ID (for create)"),
      name: z.string().optional().describe("Name (for create)"),
      description: z.string().optional().describe("Description (for create)"),
      icon: z.string().optional().describe("Icon (for create)"),
      tools: z.array(z.string()).optional().describe("Tools (for create)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "init":
        return wrapResult(await initToolClusters({
          repoPath: input.repoPath,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listToolClusters({
          repoPath: input.repoPath,
        }));
      case "tools":
        return wrapResult(await getClusterTools({
          repoPath: input.repoPath,
          clusterId: input.clusterId,
        }));
      case "find":
        return wrapResult(await findToolCluster({
          repoPath: input.repoPath,
          toolName: input.toolName,
        }));
      case "add":
        return wrapResult(await addToolToCluster({
          repoPath: input.repoPath,
          clusterId: input.clusterId,
          toolName: input.toolName,
          commitMode: input.commitMode || "push",
        }));
      case "create":
        return wrapResult(await createToolCluster({
          repoPath: input.repoPath,
          id: input.id,
          name: input.name,
          description: input.description,
          icon: input.icon,
          tools: input.tools,
          commitMode: input.commitMode || "push",
        }));
      case "summary":
        return wrapResult(await getToolClusterSummary({
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 37. swarm_docs - Auto documentation
 */
export const swarmDocsTool = [
  "swarm_docs",
  {
    title: "Swarm Docs",
    description: "Auto documentation. Actions: generate, task_docs, list, get",
    inputSchema: z.object({
      action: z.enum(["generate", "task_docs", "list", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for generate, task_docs)"),
      taskId: z.string().optional().describe("Task ID (for generate, task_docs, get)"),
      feature: z.string().optional().describe("Feature name (for generate)"),
      description: z.string().optional().describe("Description (for generate)"),
      usage: z.string().optional().describe("Usage (for generate)"),
      taskTitle: z.string().optional().describe("Task title (for task_docs)"),
      filesModified: z.array(z.string()).optional().describe("Files modified (for task_docs)"),
      summary: z.string().optional().describe("Summary (for task_docs)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "generate":
        return wrapResult(await autoGenerateDocs({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          feature: input.feature,
          description: input.description,
          usage: input.usage,
          commitMode: input.commitMode || "push",
        }));
      case "task_docs":
        return wrapResult(await generateTaskDocumentation({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskTitle,
          agent: input.agent,
          filesModified: input.filesModified || [],
          summary: input.summary,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listDocumentation(input.repoPath));
      case "get":
        return wrapResult(await getDocumentation({
          repoPath: input.repoPath,
          taskId: input.taskId,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 35. swarm_conflict - Conflict prediction
 */
export const swarmConflictTool = [
  "swarm_conflict",
  {
    title: "Swarm Conflict",
    description: "Conflict prediction. Actions: predict, analyze, hotspots, record",
    inputSchema: z.object({
      action: z.enum(["predict", "analyze", "hotspots", "record"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      filesToEdit: z.array(z.string()).optional().describe("Files to edit (for predict)"),
      file: z.string().optional().describe("File (for record)"),
      agent: z.string().optional().describe("Agent (for record)"),
      resolved: z.boolean().optional().describe("Resolved (for record)"),
      lookbackDays: z.number().optional().describe("Lookback days (for analyze)"),
      limit: z.number().optional().describe("Limit (for hotspots)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "predict":
        return wrapResult(await predictConflicts({
          repoPath: input.repoPath,
          filesToEdit: input.filesToEdit || [],
        }));
      case "analyze":
        return wrapResult(await analyzeConflictHistory({
          repoPath: input.repoPath,
          lookbackDays: input.lookbackDays,
          commitMode: input.commitMode || "push",
        }));
      case "hotspots":
        return wrapResult(await getConflictHotspots({
          repoPath: input.repoPath,
          limit: input.limit,
        }));
      case "record":
        return wrapResult(await recordConflictEvent({
          repoPath: input.repoPath,
          file: input.file,
          agent: input.agent,
          resolved: input.resolved ?? false,
          commitMode: input.commitMode || "push",
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 19. swarm_health - Agent health monitoring
 */
export const swarmHealthTool = [
  "swarm_health",
  {
    title: "Swarm Health",
    description: "Agent health monitoring. Actions: check, dead, reassign, summary",
    inputSchema: z.object({
      action: z.enum(["check", "dead", "reassign", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for check)"),
      thresholdMinutes: z.number().optional().describe("Threshold minutes"),
      taskId: z.string().optional().describe("Task ID (for reassign)"),
      fromAgent: z.string().optional().describe("From agent (for reassign)"),
      toAgent: z.string().optional().describe("To agent (for reassign)"),
      reason: z.string().optional().describe("Reason (for reassign)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "check":
        return wrapResult(await checkAgentHealth({
          repoPath: input.repoPath,
          agent: input.agent,
          thresholdMinutes: input.thresholdMinutes,
        }));
      case "dead":
        return wrapResult(await getDeadAgents({
          repoPath: input.repoPath,
          thresholdMinutes: input.thresholdMinutes,
        }));
      case "reassign":
        return wrapResult(await forceReassignTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          fromAgent: input.fromAgent,
          toAgent: input.toAgent,
          reason: input.reason,
          commitMode: input.commitMode || "push",
        }));
      case "summary":
        return wrapResult(await getSwarmHealthSummary({
          repoPath: input.repoPath,
          thresholdMinutes: input.thresholdMinutes,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 26. swarm_qa - QA loop management
 */
export const swarmQaTool = [
  "swarm_qa",
  {
    title: "Swarm QA",
    description: "QA loop management. Actions: start, iterate, fix, get, list, suggest, report",
    inputSchema: z.object({
      action: z.enum(["start", "iterate", "fix", "get", "list", "suggest", "report"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for start)"),
      branch: z.string().optional().describe("Branch (for start)"),
      maxIterations: z.number().optional().describe("Max iterations (for start)"),
      autoFix: z.boolean().optional().describe("Auto fix (for start)"),
      checks: z.array(z.string()).optional().describe("Checks (for start)"),
      loopId: z.string().optional().describe("Loop ID"),
      checkResults: z.any().optional().describe("Check results (for iterate)"),
      fixDescription: z.string().optional().describe("Fix description (for fix)"),
      status: z.string().optional().describe("Status filter (for list)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startQALoop({
          repoPath: input.repoPath,
          taskId: input.taskId,
          branch: input.branch,
          maxIterations: input.maxIterations,
          autoFix: input.autoFix,
          checks: input.checks,
          commitMode: input.commitMode || "push",
        }));
      case "iterate":
        return wrapResult(await runQAIteration({
          repoPath: input.repoPath,
          loopId: input.loopId,
          checkResults: input.checkResults,
          commitMode: input.commitMode || "push",
        }));
      case "fix":
        return wrapResult(await logQAFix({
          repoPath: input.repoPath,
          loopId: input.loopId,
          fixDescription: input.fixDescription,
          commitMode: input.commitMode || "push",
        }));
      case "get":
        return wrapResult(await getQALoop({
          repoPath: input.repoPath,
          loopId: input.loopId,
        }));
      case "list":
        return wrapResult(await listQALoops({
          repoPath: input.repoPath,
          status: input.status,
        }));
      case "suggest":
        return wrapResult(await getQAFixSuggestions({
          repoPath: input.repoPath,
          loopId: input.loopId,
        }));
      case "report":
        return wrapResult(await generateQAReport({
          repoPath: input.repoPath,
          loopId: input.loopId,
          commitMode: input.commitMode || "push",
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 38. swarm_advice - Collective advice
 */
export const swarmAdviceTool = [
  "swarm_advice",
  {
    title: "Swarm Advice",
    description: "Collective advice. Actions: request, provide, list",
    inputSchema: z.object({
      action: z.enum(["request", "provide", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID (for request)"),
      problem: z.string().optional().describe("Problem (for request)"),
      context: z.string().optional().describe("Context (for request)"),
      codeSnippet: z.string().optional().describe("Code snippet (for request)"),
      filesInvolved: z.array(z.string()).optional().describe("Files involved (for request)"),
      attemptedSolutions: z.array(z.string()).optional().describe("Attempted solutions (for request)"),
      requestId: z.string().optional().describe("Request ID (for provide)"),
      suggestion: z.string().optional().describe("Suggestion (for provide)"),
      confidence: z.enum(["low", "medium", "high"]).optional().describe("Confidence (for provide)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "request":
        return wrapResult(await requestCollectiveAdvice({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          problem: input.problem,
          context: input.context,
          codeSnippet: input.codeSnippet,
          filesInvolved: input.filesInvolved || [],
          attemptedSolutions: input.attemptedSolutions || [],
          commitMode: input.commitMode || "push",
        }));
      case "provide":
        return wrapResult(await provideAdvice({
          repoPath: input.repoPath,
          requestId: input.requestId,
          agent: input.agent,
          suggestion: input.suggestion,
          confidence: input.confidence,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await getOpenAdviceRequests(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 44. swarm_autoreview - Automatic code review assignment
 */
export const swarmAutoReviewTool = [
  "swarm_autoreview",
  {
    title: "Swarm Auto Review",
    description: "Automatic code review assignment. Actions: create, assign, comment, complete, resolve, for_reviewer, for_author, pending, stats",
    inputSchema: z.object({
      action: z.enum(["create", "assign", "comment", "complete", "resolve", "for_reviewer", "for_author", "pending", "stats"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for create)"),
      authorId: z.string().optional().describe("Author agent ID"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files"),
      reviewId: z.string().optional().describe("Review ID"),
      reviewerId: z.string().optional().describe("Reviewer agent ID"),
      filePath: z.string().optional().describe("File path (for comment)"),
      line: z.number().optional().describe("Line number (for comment)"),
      commentText: z.string().optional().describe("Comment text"),
      severity: z.enum(["critical", "major", "minor", "suggestion"]).optional().describe("Comment severity"),
      approved: z.boolean().optional().describe("Approved (for complete)"),
      summary: z.string().optional().describe("Review summary"),
      commentId: z.string().optional().describe("Comment ID (for resolve)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "create":
        return wrapResult(await createReviewRequest({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskId,
          codeAuthor: input.authorId,
          changedFiles: input.affectedFiles || [],
          changesSummary: input.summary || "",
        }));
      case "assign":
        return wrapResult(await assignReviewer({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          reviewer: input.reviewerId,
        }));
      case "comment":
        return wrapResult(await addReviewComment({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          author: input.reviewerId,
          filePath: input.filePath,
          lineNumber: input.line,
          content: input.commentText,
          severity: input.severity === "critical" ? "blocker" : input.severity === "major" ? "warning" : input.severity === "minor" ? "suggestion" : "info",
        }));
      case "complete":
        return wrapResult(await completeReview({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          reviewer: input.reviewerId,
          approved: input.approved ?? false,
          summary: input.summary || "",
        }));
      case "resolve":
        return wrapResult(await resolveComment({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          commentId: input.commentId,
        }));
      case "for_reviewer":
        return wrapResult(await getReviewsForReviewer({
          repoPath: input.repoPath,
          reviewer: input.reviewerId,
        }));
      case "for_author":
        return wrapResult(await getReviewsForAuthor({
          repoPath: input.repoPath,
          author: input.authorId,
        }));
      case "pending":
        return wrapResult(await getPendingReviews({ repoPath: input.repoPath }));
      case "stats":
        return wrapResult(await getReviewStats({ repoPath: input.repoPath }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 47. swarm_telegram - Telegram Bot integration
 */
export const swarmTelegramTool = [
  "swarm_telegram",
  {
    title: "Swarm Telegram",
    description: "Telegram Bot integration for notifications and control. Actions: setup, config, enable, disable, send, notify_task_created, notify_task_completed, notify_task_failed, notify_agent_joined, notify_agent_died, start_polling, stop_polling, command",
    inputSchema: z.object({
      action: z.enum([
        "setup", "config", "enable", "disable", "send",
        "notify_task_created", "notify_task_completed", "notify_task_failed",
        "notify_agent_joined", "notify_agent_died",
        "start_polling", "stop_polling", "command"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // Config
      botToken: z.string().optional().describe("Telegram Bot Token (from @BotFather)"),
      chatId: z.string().optional().describe("Chat ID for notifications"),
      enabled: z.boolean().optional().describe("Enable/disable bot"),
      // Notifications
      taskId: z.string().optional().describe("Task ID"),
      title: z.string().optional().describe("Task title"),
      priority: z.string().optional().describe("Task priority"),
      agent: z.string().optional().describe("Agent name"),
      message: z.string().optional().describe("Message text"),
      // Command
      command: z.string().optional().describe("Bot command (e.g., /status)"),
      args: z.array(z.string()).optional().describe("Command arguments"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    return wrapResult(await handleTelegramTool({ ...input, repoPath }));
  },
] as const;

/**
 * 48. swarm_batch - Request batching for cost optimization
 */

