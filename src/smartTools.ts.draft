/**
 * MCP Swarm v0.9.0 - Smart Tools
 * 
 * Объединение 168+ отдельных tools в 41 Smart Tool с параметром action.
 * Каждый Smart Tool группирует связанный функционал.
 */

import { z } from "zod";

// ============ IMPORTS FROM WORKFLOWS ============

// Agent & Registry
import { registerAgent, whoami } from "./workflows/agentRegistry.js";

// Tasks
import {
  createTaskFile,
  type TaskCreateInput,
} from "./workflows/taskFile.js";
import { listTasks, updateTask } from "./workflows/taskState.js";
import { decomposeTask, getDecomposition } from "./workflows/decompose.js";

// Files
import { fileReserve, fileRelease, listFileLocks } from "./workflows/fileLocks.js";
import { forecastFileTouches, getActiveForecasts, checkFileConflicts } from "./workflows/conflictForecast.js";
import { checkFileSafety } from "./workflows/conflictPrediction.js";

// Git
import { syncWithBaseBranch } from "./workflows/git.js";
import { createGithubPr, checkMainHealth } from "./workflows/githubPr.js";
import { autoDeleteMergedBranch, cleanupAllMergedBranches } from "./workflows/remoteCleanup.js";

// Worktree
import { createWorktree, listWorktrees, removeWorktree } from "./workflows/worktree.js";

// Companion Control
import {
  companionLocalPause,
  companionLocalResume,
  companionLocalStatus,
  companionLocalStop,
} from "./workflows/companionControl.js";

// Stop Flag
import { getStopState, setStopState } from "./workflows/stopFlag.js";

// Team Files
import { appendTeamChat, updateTeamStatus } from "./workflows/teamFiles.js";
import { logSwarmThought, getRecentThoughts } from "./workflows/swarmThoughts.js";

// Review
import { requestCrossAgentReview, respondToReview, listPendingReviews } from "./workflows/codeReview.js";

// Screenshot
import { shareScreenshot, listScreenshots } from "./workflows/screenshot.js";

// Voting
import { startVoting, castVote, getVotingSession, listOpenVotings } from "./workflows/voting.js";

// Auction
import { announceTaskForBidding, bidForTask, pollSwarmEvents } from "./workflows/auction.js";

// MCP Scanner
import { scanSystemMcps, authorizeMcpsForSwarm, getPolicy } from "./workflows/mcpScanner.js";

// Dependency
import { signalDependencyChange, syncDependencies } from "./workflows/dependencySync.js";

// Platform
import { requestPlatformCheck, respondToPlatformCheck, getPendingPlatformChecks } from "./workflows/crossPlatform.js";

// Immune System
import { reportCiAlert, resolveAlert, getImmuneStatus, runLocalTests } from "./workflows/immuneSystem.js";
import { patrolMode } from "./workflows/ghostMode.js";

// Briefings
import { saveBriefing, loadBriefing } from "./workflows/briefings.js";

// Pulse
import { updateSwarmPulse, getSwarmPulse } from "./workflows/pulse.js";

// Knowledge
import { archiveFinding, searchKnowledge } from "./workflows/knowledgeBase.js";

// Preemption
import { triggerUrgentPreemption, resolveUrgent, getActiveUrgent } from "./workflows/preemption.js";

// Snapshot
import { createSnapshot, triggerRollback, listSnapshots } from "./workflows/snapshot.js";

// Advice
import { requestCollectiveAdvice, provideAdvice, getOpenAdviceRequests } from "./workflows/collectiveAdvice.js";

// Docs
import { autoGenerateDocs, listDocs } from "./workflows/autoDoc.js";
import { generateTaskDocumentation, listDocumentation, getDocumentation } from "./workflows/autoDocumentation.js";

// Expertise
import { trackExpertise, suggestAgentForTask, getAgentExpertise } from "./workflows/specialization.js";
import { recordAgentEdit, suggestAgentForTask as suggestAgentAdvanced, getTopExperts, listAllAgentExpertise } from "./workflows/agentSpecialization.js";

// Conflict
import { predictConflicts, analyzeConflictHistory, getConflictHotspots, recordConflictEvent } from "./workflows/conflictPrediction.js";

// Timeline
import { generateTimeline, getTimelineVisualization } from "./workflows/timeline.js";

// Health
import { checkAgentHealth, getDeadAgents, forceReassignTask, getSwarmHealthSummary } from "./workflows/agentHealth.js";

// Session
import { startSessionRecording, logSessionAction, stopSessionRecording, listSessionRecordings, replaySession } from "./workflows/sessionRecording.js";

// Quality
import { runQualityGate, getQualityReport, setQualityThreshold, checkPrReady } from "./workflows/qualityGate.js";

// Cost
import { logApiUsage, getAgentCosts, getProjectCosts, setBudgetLimit, checkBudgetRemaining } from "./workflows/costTracker.js";

// Context
import { estimateContextSize, compressBriefing, compressMultipleBriefings, getCompressionStats } from "./workflows/contextCompressor.js";

// Regression
import { saveBaseline, checkRegression, listRegressions, resolveRegression, listBaselines } from "./workflows/regressionDetector.js";

// Brainstorming
import {
  startBrainstorm,
  askBrainstormQuestion,
  answerBrainstormQuestion,
  proposeApproaches,
  presentDesignSection,
  validateDesignSection,
  saveDesignDocument,
  getBrainstormSession,
  listBrainstormSessions,
} from "./workflows/brainstorming.js";

// Plans
import {
  createImplementationPlan,
  addPlanTask,
  getNextTask,
  startTask,
  completeStep,
  completeTask,
  generateSubagentPrompt,
  exportPlanAsMarkdown,
  getPlanStatus,
  listPlans,
  markPlanReady,
} from "./workflows/writingPlans.js";

// Debug
import {
  startDebugSession,
  logInvestigation,
  addEvidence,
  completePhase1,
  logPatterns,
  completePhase2,
  formHypothesis,
  testHypothesis,
  implementFix,
  verifyFix,
  getDebugSession,
  listDebugSessions,
  checkRedFlags,
} from "./workflows/systematicDebugging.js";

// Spec Pipeline
import {
  startSpecPipeline,
  startSpecPhase,
  completeSpecPhase,
  getSpecPipeline,
  listSpecPipelines,
  exportSpecAsMarkdown,
} from "./workflows/specPipeline.js";

// QA Loop
import {
  startQALoop,
  runQAIteration,
  logQAFix,
  getQALoop,
  listQALoops,
  getQAFixSuggestions,
  generateQAReport,
} from "./workflows/qaLoop.js";

// Guard Hooks
import {
  installGuardHooks,
  uninstallGuardHooks,
  runGuardHooks,
  getGuardConfig,
  updateGuardHook,
  listGuardHooks,
} from "./workflows/guardHooks.js";

// Tool Clusters
import {
  initToolClusters,
  listToolClusters,
  getClusterTools,
  findToolCluster,
  addToolToCluster,
  createToolCluster,
  getToolClusterSummary,
} from "./workflows/toolClusters.js";

// Orchestrator
import {
  tryBecomeOrchestrator,
  getOrchestratorInfo,
  orchestratorHeartbeat,
  resignOrchestrator,
  listExecutors,
  executorHeartbeat,
  sendAgentMessage,
  fetchAgentInbox,
  acknowledgeMessage,
  replyToMessage,
  searchMessages,
  getThreadMessages,
} from "./workflows/orchestrator.js";


// ============ SMART TOOLS ============

/**
 * 1. swarm_agent - Agent registration and identity
 */
export const swarmAgentTool = [
  "swarm_agent",
  {
    title: "Swarm Agent",
    description: "Agent registration and identity management. Actions: register, whoami",
    inputSchema: z.object({
      action: z.enum(["register", "whoami"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: { action: string; repoPath?: string; commitMode?: "none" | "local" | "push" }) => {
    let result: any;
    switch (input.action) {
      case "register":
        result = await registerAgent({ repoPath: input.repoPath, commitMode: input.commitMode || "push" });
        break;
      case "whoami":
        result = await whoami(input.repoPath || process.cwd());
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 2. swarm_task - Task management
 */
export const swarmTaskTool = [
  "swarm_task",
  {
    title: "Swarm Task",
    description: "Task management. Actions: create, list, assign, status, done, cancel, link, decompose, get_decomposition",
    inputSchema: z.object({
      action: z.enum(["create", "list", "assign", "status", "done", "cancel", "link", "decompose", "get_decomposition"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for assign, status, done, cancel, link, decompose)"),
      title: z.string().optional().describe("Task title (for create)"),
      description: z.string().optional().describe("Task description (for create)"),
      assignee: z.string().optional().describe("Agent name to assign (for assign)"),
      newStatus: z.string().optional().describe("New status (for status)"),
      links: z.array(z.string()).optional().describe("Linked task IDs (for link)"),
      filter: z.object({
        status: z.string().optional(),
        assignee: z.string().optional(),
      }).optional().describe("Filter for list"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "create":
        result = await createTaskFile({
          repoPath: input.repoPath,
          title: input.title,
          description: input.description,
          commitMode,
        });
        break;
      case "list":
        result = await listTasks({ repoPath: input.repoPath, filter: input.filter });
        break;
      case "assign":
        result = await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          assignee: input.assignee,
          commitMode,
        });
        break;
      case "status":
        result = await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          status: input.newStatus,
          commitMode,
        });
        break;
      case "done":
        result = await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          status: "done",
          commitMode,
        });
        break;
      case "cancel":
        result = await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          status: "cancelled",
          commitMode,
        });
        break;
      case "link":
        result = await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          links: input.links,
          commitMode,
        });
        break;
      case "decompose":
        result = await decomposeTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          commitMode,
        });
        break;
      case "get_decomposition":
        result = await getDecomposition({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 3. swarm_file - File locking and conflict management
 */
export const swarmFileTool = [
  "swarm_file",
  {
    title: "Swarm File",
    description: "File locking and conflict management. Actions: reserve, release, list, forecast, conflicts, safety",
    inputSchema: z.object({
      action: z.enum(["reserve", "release", "list", "forecast", "conflicts", "safety"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      filePath: z.string().optional().describe("File path (for reserve, release, safety)"),
      filePaths: z.array(z.string()).optional().describe("File paths (for forecast)"),
      agentName: z.string().optional().describe("Agent name"),
      exclusive: z.boolean().optional().default(true).describe("Exclusive lock (for reserve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "reserve":
        result = await fileReserve({
          repoPath: input.repoPath,
          filePath: input.filePath,
          agentName: input.agentName,
          exclusive: input.exclusive ?? true,
          commitMode: input.commitMode || "push",
        });
        break;
      case "release":
        result = await fileRelease({
          repoPath: input.repoPath,
          filePath: input.filePath,
          agentName: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await listFileLocks({ repoPath: input.repoPath });
        break;
      case "forecast":
        result = await forecastFileTouches({
          repoPath: input.repoPath,
          agentName: input.agentName,
          filePaths: input.filePaths,
          commitMode: input.commitMode || "push",
        });
        break;
      case "conflicts":
        result = await checkFileConflicts({ repoPath: input.repoPath });
        break;
      case "safety":
        result = await checkFileSafety({
          repoPath: input.repoPath,
          filePath: input.filePath,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 4. swarm_git - Git operations
 */
export const swarmGitTool = [
  "swarm_git",
  {
    title: "Swarm Git",
    description: "Git operations. Actions: sync, pr, health, cleanup, cleanup_all",
    inputSchema: z.object({
      action: z.enum(["sync", "pr", "health", "cleanup", "cleanup_all"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      baseBranch: z.string().optional().describe("Base branch (for sync)"),
      title: z.string().optional().describe("PR title (for pr)"),
      body: z.string().optional().describe("PR body (for pr)"),
      branchName: z.string().optional().describe("Branch name (for cleanup)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "sync":
        result = await syncWithBaseBranch({
          repoPath: input.repoPath,
          baseBranch: input.baseBranch,
        });
        break;
      case "pr":
        result = await createGithubPr({
          repoPath: input.repoPath,
          title: input.title,
          body: input.body,
        });
        break;
      case "health":
        result = await checkMainHealth({ repoPath: input.repoPath });
        break;
      case "cleanup":
        result = await autoDeleteMergedBranch({
          repoPath: input.repoPath,
          branchName: input.branchName,
        });
        break;
      case "cleanup_all":
        result = await cleanupAllMergedBranches({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 5. swarm_worktree - Git worktree management
 */
export const swarmWorktreeTool = [
  "swarm_worktree",
  {
    title: "Swarm Worktree",
    description: "Git worktree management. Actions: create, list, remove",
    inputSchema: z.object({
      action: z.enum(["create", "list", "remove"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      branchName: z.string().optional().describe("Branch name (for create, remove)"),
      baseBranch: z.string().optional().describe("Base branch (for create)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "create":
        result = await createWorktree({
          repoPath: input.repoPath,
          branchName: input.branchName,
          baseBranch: input.baseBranch,
        });
        break;
      case "list":
        result = await listWorktrees({ repoPath: input.repoPath });
        break;
      case "remove":
        result = await removeWorktree({
          repoPath: input.repoPath,
          branchName: input.branchName,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 6. swarm_companion - Companion daemon control
 */
export const swarmCompanionTool = [
  "swarm_companion",
  {
    title: "Swarm Companion",
    description: "Companion daemon control. Actions: status, stop, pause, resume",
    inputSchema: z.object({
      action: z.enum(["status", "stop", "pause", "resume"]).describe("Action to perform"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: { action: string }) => {
    let result: any;
    
    switch (input.action) {
      case "status":
        result = await companionLocalStatus();
        break;
      case "stop":
        result = await companionLocalStop();
        break;
      case "pause":
        result = await companionLocalPause();
        break;
      case "resume":
        result = await companionLocalResume();
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 7. swarm_control - Swarm stop/resume control
 */
export const swarmControlTool = [
  "swarm_control",
  {
    title: "Swarm Control",
    description: "Swarm stop/resume control. Actions: stop, resume, status",
    inputSchema: z.object({
      action: z.enum(["stop", "resume", "status"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      reason: z.string().optional().describe("Reason for stop"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "stop":
        result = await setStopState({
          repoPath: input.repoPath,
          stopped: true,
          reason: input.reason,
          commitMode: input.commitMode || "push",
        });
        break;
      case "resume":
        result = await setStopState({
          repoPath: input.repoPath,
          stopped: false,
          commitMode: input.commitMode || "push",
        });
        break;
      case "status":
        result = await getStopState({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 8. swarm_chat - Team communication
 */
export const swarmChatTool = [
  "swarm_chat",
  {
    title: "Swarm Chat",
    description: "Team communication. Actions: broadcast, dashboard, thought, thoughts",
    inputSchema: z.object({
      action: z.enum(["broadcast", "dashboard", "thought", "thoughts"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      message: z.string().optional().describe("Message to broadcast or log"),
      agentName: z.string().optional().describe("Agent name"),
      status: z.string().optional().describe("Status for dashboard"),
      limit: z.number().optional().describe("Limit for thoughts"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "broadcast":
        result = await appendTeamChat({
          repoPath: input.repoPath,
          message: input.message,
          agentName: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "dashboard":
        result = await updateTeamStatus({
          repoPath: input.repoPath,
          agentName: input.agentName,
          status: input.status,
          commitMode: input.commitMode || "push",
        });
        break;
      case "thought":
        result = await logSwarmThought({
          repoPath: input.repoPath,
          agentName: input.agentName,
          thought: input.message,
          commitMode: input.commitMode || "push",
        });
        break;
      case "thoughts":
        result = await getRecentThoughts({
          repoPath: input.repoPath,
          limit: input.limit,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 9. swarm_review - Code review between agents
 */
export const swarmReviewTool = [
  "swarm_review",
  {
    title: "Swarm Review",
    description: "Code review between agents. Actions: request, respond, list",
    inputSchema: z.object({
      action: z.enum(["request", "respond", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      reviewId: z.string().optional().describe("Review ID (for respond)"),
      filePath: z.string().optional().describe("File path (for request)"),
      agentName: z.string().optional().describe("Agent name"),
      approved: z.boolean().optional().describe("Approval status (for respond)"),
      comment: z.string().optional().describe("Review comment"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "request":
        result = await requestCrossAgentReview({
          repoPath: input.repoPath,
          filePath: input.filePath,
          requestingAgent: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "respond":
        result = await respondToReview({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          reviewerAgent: input.agentName,
          approved: input.approved,
          comment: input.comment,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await listPendingReviews({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 10. swarm_voting - Voting for dangerous actions
 */
export const swarmVotingTool = [
  "swarm_voting",
  {
    title: "Swarm Voting",
    description: "Voting for dangerous actions. Actions: start, vote, list, get",
    inputSchema: z.object({
      action: z.enum(["start", "vote", "list", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      votingId: z.string().optional().describe("Voting ID"),
      topic: z.string().optional().describe("Voting topic (for start)"),
      description: z.string().optional().describe("Description (for start)"),
      agentName: z.string().optional().describe("Agent name"),
      vote: z.enum(["approve", "reject"]).optional().describe("Vote (for vote)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "start":
        result = await startVoting({
          repoPath: input.repoPath,
          topic: input.topic,
          description: input.description,
          initiator: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "vote":
        result = await castVote({
          repoPath: input.repoPath,
          votingId: input.votingId,
          agentName: input.agentName,
          vote: input.vote,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await listOpenVotings({ repoPath: input.repoPath });
        break;
      case "get":
        result = await getVotingSession({
          repoPath: input.repoPath,
          votingId: input.votingId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 11. swarm_auction - Task auction system
 */
export const swarmAuctionTool = [
  "swarm_auction",
  {
    title: "Swarm Auction",
    description: "Task auction system. Actions: announce, bid, poll",
    inputSchema: z.object({
      action: z.enum(["announce", "bid", "poll"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      agentName: z.string().optional().describe("Agent name"),
      capabilities: z.array(z.string()).optional().describe("Agent capabilities (for bid)"),
      sinceTs: z.number().optional().describe("Timestamp for poll"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "announce":
        result = await announceTaskForBidding({
          repoPath: input.repoPath,
          taskId: input.taskId,
          commitMode: input.commitMode || "push",
        });
        break;
      case "bid":
        result = await bidForTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          agentName: input.agentName,
          capabilities: input.capabilities,
          commitMode: input.commitMode || "push",
        });
        break;
      case "poll":
        result = await pollSwarmEvents({
          repoPath: input.repoPath,
          sinceTs: input.sinceTs,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 12. swarm_mcp - MCP scanner and authorization
 */
export const swarmMcpTool = [
  "swarm_mcp",
  {
    title: "Swarm MCP",
    description: "MCP scanner and authorization. Actions: scan, authorize, policy",
    inputSchema: z.object({
      action: z.enum(["scan", "authorize", "policy"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      mcpNames: z.array(z.string()).optional().describe("MCP names to authorize"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "scan":
        result = await scanSystemMcps();
        break;
      case "authorize":
        result = await authorizeMcpsForSwarm({
          repoPath: input.repoPath,
          mcpNames: input.mcpNames,
          commitMode: input.commitMode || "push",
        });
        break;
      case "policy":
        result = await getPolicy({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 13. swarm_orchestrator - Orchestrator election and management
 */
export const swarmOrchestratorTool = [
  "swarm_orchestrator",
  {
    title: "Swarm Orchestrator",
    description: "Orchestrator election and management. Actions: elect, info, heartbeat, resign, executors, executor_heartbeat",
    inputSchema: z.object({
      action: z.enum(["elect", "info", "heartbeat", "resign", "executors", "executor_heartbeat"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID"),
      agentName: z.string().optional().describe("Agent name"),
      platform: z.string().optional().describe("Platform (e.g., claude, cursor)"),
      currentTask: z.string().optional().describe("Current task (for executor_heartbeat)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "elect":
        result = await tryBecomeOrchestrator({
          repoPath: input.repoPath,
          agentId: input.agentId,
          agentName: input.agentName,
          platform: input.platform,
        });
        break;
      case "info":
        result = await getOrchestratorInfo({ repoPath: input.repoPath });
        break;
      case "heartbeat":
        result = await orchestratorHeartbeat({
          repoPath: input.repoPath,
          agentId: input.agentId,
        });
        break;
      case "resign":
        result = await resignOrchestrator({
          repoPath: input.repoPath,
          agentId: input.agentId,
        });
        break;
      case "executors":
        result = await listExecutors({ repoPath: input.repoPath });
        break;
      case "executor_heartbeat":
        result = await executorHeartbeat({
          repoPath: input.repoPath,
          agentId: input.agentId,
          currentTask: input.currentTask,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 14. swarm_message - Agent messaging system
 */
export const swarmMessageTool = [
  "swarm_message",
  {
    title: "Swarm Message",
    description: "Agent messaging system. Actions: send, inbox, ack, reply, search, thread",
    inputSchema: z.object({
      action: z.enum(["send", "inbox", "ack", "reply", "search", "thread"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      from: z.string().optional().describe("Sender agent name"),
      to: z.union([z.string(), z.array(z.string())]).optional().describe("Recipient(s) or '*' for broadcast"),
      subject: z.string().optional().describe("Message subject"),
      body: z.string().optional().describe("Message body"),
      agentName: z.string().optional().describe("Agent name (for inbox, ack)"),
      messageId: z.string().optional().describe("Message ID (for ack, reply)"),
      threadId: z.string().optional().describe("Thread ID"),
      query: z.string().optional().describe("Search query"),
      limit: z.number().optional().describe("Limit for inbox/search"),
      importance: z.enum(["low", "normal", "high", "urgent"]).optional(),
      ackRequired: z.boolean().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "send":
        result = await sendAgentMessage({
          repoPath: input.repoPath,
          from: input.from,
          to: input.to,
          subject: input.subject,
          body: input.body,
          importance: input.importance,
          threadId: input.threadId,
          ackRequired: input.ackRequired,
        });
        break;
      case "inbox":
        result = await fetchAgentInbox({
          repoPath: input.repoPath,
          agentName: input.agentName,
          limit: input.limit,
        });
        break;
      case "ack":
        result = await acknowledgeMessage({
          repoPath: input.repoPath,
          agentName: input.agentName,
          messageId: input.messageId,
        });
        break;
      case "reply":
        result = await replyToMessage({
          repoPath: input.repoPath,
          from: input.from,
          messageId: input.messageId,
          body: input.body,
        });
        break;
      case "search":
        result = await searchMessages({
          repoPath: input.repoPath,
          query: input.query,
          limit: input.limit,
        });
        break;
      case "thread":
        result = await getThreadMessages({
          repoPath: input.repoPath,
          threadId: input.threadId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 15. swarm_briefing - Briefing management
 */
export const swarmBriefingTool = [
  "swarm_briefing",
  {
    title: "Swarm Briefing",
    description: "Briefing management for mental snapshots. Actions: save, load",
    inputSchema: z.object({
      action: z.enum(["save", "load"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      briefingId: z.string().optional().describe("Briefing ID (for load)"),
      content: z.string().optional().describe("Briefing content (for save)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "save":
        result = await saveBriefing({
          repoPath: input.repoPath,
          agentName: input.agentName,
          content: input.content,
          commitMode: input.commitMode || "push",
        });
        break;
      case "load":
        result = await loadBriefing({
          repoPath: input.repoPath,
          briefingId: input.briefingId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 16. swarm_pulse - Swarm pulse (live map)
 */
export const swarmPulseTool = [
  "swarm_pulse",
  {
    title: "Swarm Pulse",
    description: "Swarm pulse - live agent map. Actions: update, get",
    inputSchema: z.object({
      action: z.enum(["update", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      status: z.string().optional().describe("Agent status"),
      currentFile: z.string().optional().describe("Current file being edited"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "update":
        result = await updateSwarmPulse({
          repoPath: input.repoPath,
          agentName: input.agentName,
          status: input.status,
          currentFile: input.currentFile,
          commitMode: input.commitMode || "push",
        });
        break;
      case "get":
        result = await getSwarmPulse({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 17. swarm_knowledge - Knowledge base
 */
export const swarmKnowledgeTool = [
  "swarm_knowledge",
  {
    title: "Swarm Knowledge",
    description: "Knowledge base for collective learnings. Actions: archive, search",
    inputSchema: z.object({
      action: z.enum(["archive", "search"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      finding: z.string().optional().describe("Finding to archive"),
      category: z.string().optional().describe("Category for finding"),
      agentName: z.string().optional().describe("Agent name"),
      query: z.string().optional().describe("Search query"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "archive":
        result = await archiveFinding({
          repoPath: input.repoPath,
          finding: input.finding,
          category: input.category,
          agentName: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "search":
        result = await searchKnowledge({
          repoPath: input.repoPath,
          query: input.query,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 18. swarm_snapshot - Snapshot and rollback
 */
export const swarmSnapshotTool = [
  "swarm_snapshot",
  {
    title: "Swarm Snapshot",
    description: "Snapshot and rollback system. Actions: create, rollback, list",
    inputSchema: z.object({
      action: z.enum(["create", "rollback", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      snapshotId: z.string().optional().describe("Snapshot ID (for rollback)"),
      description: z.string().optional().describe("Snapshot description"),
      agentName: z.string().optional().describe("Agent name"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "create":
        result = await createSnapshot({
          repoPath: input.repoPath,
          description: input.description,
          agentName: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "rollback":
        result = await triggerRollback({
          repoPath: input.repoPath,
          snapshotId: input.snapshotId,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await listSnapshots({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 19. swarm_health - Agent health monitoring
 */
export const swarmHealthTool = [
  "swarm_health",
  {
    title: "Swarm Health",
    description: "Agent health monitoring. Actions: check, dead, reassign, summary",
    inputSchema: z.object({
      action: z.enum(["check", "dead", "reassign", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name (for check)"),
      taskId: z.string().optional().describe("Task ID (for reassign)"),
      newAssignee: z.string().optional().describe("New assignee (for reassign)"),
      inactiveMinutes: z.number().optional().describe("Inactive threshold (for dead)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "check":
        result = await checkAgentHealth({
          repoPath: input.repoPath,
          agentName: input.agentName,
        });
        break;
      case "dead":
        result = await getDeadAgents({
          repoPath: input.repoPath,
          inactiveMinutes: input.inactiveMinutes,
        });
        break;
      case "reassign":
        result = await forceReassignTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          newAssignee: input.newAssignee,
          commitMode: input.commitMode || "push",
        });
        break;
      case "summary":
        result = await getSwarmHealthSummary({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 20. swarm_quality - Quality gate
 */
export const swarmQualityTool = [
  "swarm_quality",
  {
    title: "Swarm Quality",
    description: "Quality gate for code checks. Actions: run, report, threshold, pr_ready",
    inputSchema: z.object({
      action: z.enum(["run", "report", "threshold", "pr_ready"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      thresholds: z.object({
        lint: z.number().optional(),
        tests: z.number().optional(),
        coverage: z.number().optional(),
      }).optional().describe("Quality thresholds"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "run":
        result = await runQualityGate({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      case "report":
        result = await getQualityReport({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      case "threshold":
        result = await setQualityThreshold({
          repoPath: input.repoPath,
          thresholds: input.thresholds,
          commitMode: input.commitMode || "push",
        });
        break;
      case "pr_ready":
        result = await checkPrReady({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 21. swarm_cost - Cost tracking
 */
export const swarmCostTool = [
  "swarm_cost",
  {
    title: "Swarm Cost",
    description: "API cost tracking. Actions: log, agent, project, limit, remaining",
    inputSchema: z.object({
      action: z.enum(["log", "agent", "project", "limit", "remaining"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      tokens: z.number().optional().describe("Tokens used (for log)"),
      cost: z.number().optional().describe("Cost in USD (for log)"),
      budgetLimit: z.number().optional().describe("Budget limit (for limit)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "log":
        result = await logApiUsage({
          repoPath: input.repoPath,
          agentName: input.agentName,
          tokens: input.tokens,
          cost: input.cost,
          commitMode: input.commitMode || "push",
        });
        break;
      case "agent":
        result = await getAgentCosts({
          repoPath: input.repoPath,
          agentName: input.agentName,
        });
        break;
      case "project":
        result = await getProjectCosts({ repoPath: input.repoPath });
        break;
      case "limit":
        result = await setBudgetLimit({
          repoPath: input.repoPath,
          limit: input.budgetLimit,
          commitMode: input.commitMode || "push",
        });
        break;
      case "remaining":
        result = await checkBudgetRemaining({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 22. swarm_brainstorm - Brainstorming sessions
 */
export const swarmBrainstormTool = [
  "swarm_brainstorm",
  {
    title: "Swarm Brainstorm",
    description: "Brainstorming sessions with questions and design validation. Actions: start, ask, answer, propose, present, validate, save, get, list",
    inputSchema: z.object({
      action: z.enum(["start", "ask", "answer", "propose", "present", "validate", "save", "get", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      sessionId: z.string().optional().describe("Session ID"),
      topic: z.string().optional().describe("Topic (for start)"),
      question: z.string().optional().describe("Question text (for ask)"),
      options: z.array(z.string()).optional().describe("Answer options (for ask)"),
      answer: z.string().optional().describe("Answer (for answer)"),
      approaches: z.array(z.object({
        name: z.string(),
        pros: z.array(z.string()),
        cons: z.array(z.string()),
      })).optional().describe("Approaches (for propose)"),
      sectionName: z.string().optional().describe("Section name (for present, validate)"),
      content: z.string().optional().describe("Content (for present)"),
      approved: z.boolean().optional().describe("Approval (for validate)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "start":
        result = await startBrainstorm({
          repoPath: input.repoPath,
          topic: input.topic,
          commitMode,
        });
        break;
      case "ask":
        result = await askBrainstormQuestion({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          question: input.question,
          options: input.options,
          commitMode,
        });
        break;
      case "answer":
        result = await answerBrainstormQuestion({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          answer: input.answer,
          commitMode,
        });
        break;
      case "propose":
        result = await proposeApproaches({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          approaches: input.approaches,
          commitMode,
        });
        break;
      case "present":
        result = await presentDesignSection({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          sectionName: input.sectionName,
          content: input.content,
          commitMode,
        });
        break;
      case "validate":
        result = await validateDesignSection({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          sectionName: input.sectionName,
          approved: input.approved,
          commitMode,
        });
        break;
      case "save":
        result = await saveDesignDocument({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          commitMode,
        });
        break;
      case "get":
        result = await getBrainstormSession({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
        });
        break;
      case "list":
        result = await listBrainstormSessions({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 23. swarm_plan - Implementation plans with TDD
 */
export const swarmPlanTool = [
  "swarm_plan",
  {
    title: "Swarm Plan",
    description: "Implementation plans with TDD methodology. Actions: create, add, next, start, step, complete, prompt, export, status, list, ready",
    inputSchema: z.object({
      action: z.enum(["create", "add", "next", "start", "step", "complete", "prompt", "export", "status", "list", "ready"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      planId: z.string().optional().describe("Plan ID"),
      title: z.string().optional().describe("Plan/task title"),
      description: z.string().optional().describe("Description"),
      taskId: z.string().optional().describe("Task ID"),
      stepType: z.enum(["write_test", "run_test", "implement", "verify", "commit"]).optional().describe("TDD step type"),
      stepResult: z.string().optional().describe("Step result"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "create":
        result = await createImplementationPlan({
          repoPath: input.repoPath,
          title: input.title,
          description: input.description,
          commitMode,
        });
        break;
      case "add":
        result = await addPlanTask({
          repoPath: input.repoPath,
          planId: input.planId,
          title: input.title,
          description: input.description,
          commitMode,
        });
        break;
      case "next":
        result = await getNextTask({
          repoPath: input.repoPath,
          planId: input.planId,
        });
        break;
      case "start":
        result = await startTask({
          repoPath: input.repoPath,
          planId: input.planId,
          taskId: input.taskId,
          commitMode,
        });
        break;
      case "step":
        result = await completeStep({
          repoPath: input.repoPath,
          planId: input.planId,
          taskId: input.taskId,
          stepType: input.stepType,
          result: input.stepResult,
          commitMode,
        });
        break;
      case "complete":
        result = await completeTask({
          repoPath: input.repoPath,
          planId: input.planId,
          taskId: input.taskId,
          commitMode,
        });
        break;
      case "prompt":
        result = await generateSubagentPrompt({
          repoPath: input.repoPath,
          planId: input.planId,
          taskId: input.taskId,
        });
        break;
      case "export":
        result = await exportPlanAsMarkdown({
          repoPath: input.repoPath,
          planId: input.planId,
        });
        break;
      case "status":
        result = await getPlanStatus({
          repoPath: input.repoPath,
          planId: input.planId,
        });
        break;
      case "list":
        result = await listPlans({ repoPath: input.repoPath });
        break;
      case "ready":
        result = await markPlanReady({
          repoPath: input.repoPath,
          planId: input.planId,
          commitMode,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 24. swarm_debug - Systematic debugging (4-phase)
 */
export const swarmDebugTool = [
  "swarm_debug",
  {
    title: "Swarm Debug",
    description: "Systematic 4-phase debugging. Actions: start, investigate, evidence, phase1, patterns, phase2, hypothesis, test, fix, verify, get, list, redflags",
    inputSchema: z.object({
      action: z.enum(["start", "investigate", "evidence", "phase1", "patterns", "phase2", "hypothesis", "test", "fix", "verify", "get", "list", "redflags"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      sessionId: z.string().optional().describe("Debug session ID"),
      errorDescription: z.string().optional().describe("Error description (for start)"),
      investigation: z.string().optional().describe("Investigation notes"),
      evidence: z.string().optional().describe("Evidence to add"),
      patterns: z.string().optional().describe("Patterns found"),
      hypothesisText: z.string().optional().describe("Hypothesis text"),
      testResult: z.string().optional().describe("Test result"),
      fixDescription: z.string().optional().describe("Fix description"),
      verified: z.boolean().optional().describe("Verification result"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "start":
        result = await startDebugSession({
          repoPath: input.repoPath,
          errorDescription: input.errorDescription,
          commitMode,
        });
        break;
      case "investigate":
        result = await logInvestigation({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          investigation: input.investigation,
          commitMode,
        });
        break;
      case "evidence":
        result = await addEvidence({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          evidence: input.evidence,
          commitMode,
        });
        break;
      case "phase1":
        result = await completePhase1({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          commitMode,
        });
        break;
      case "patterns":
        result = await logPatterns({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          patterns: input.patterns,
          commitMode,
        });
        break;
      case "phase2":
        result = await completePhase2({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          commitMode,
        });
        break;
      case "hypothesis":
        result = await formHypothesis({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          hypothesis: input.hypothesisText,
          commitMode,
        });
        break;
      case "test":
        result = await testHypothesis({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          testResult: input.testResult,
          commitMode,
        });
        break;
      case "fix":
        result = await implementFix({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          fixDescription: input.fixDescription,
          commitMode,
        });
        break;
      case "verify":
        result = await verifyFix({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          verified: input.verified,
          commitMode,
        });
        break;
      case "get":
        result = await getDebugSession({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
        });
        break;
      case "list":
        result = await listDebugSessions({ repoPath: input.repoPath });
        break;
      case "redflags":
        result = await checkRedFlags({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 25. swarm_spec - Spec pipeline (gatherer → researcher → writer → critic)
 */
export const swarmSpecTool = [
  "swarm_spec",
  {
    title: "Swarm Spec",
    description: "Spec pipeline with 4 roles. Actions: start, phase, complete, get, list, export",
    inputSchema: z.object({
      action: z.enum(["start", "phase", "complete", "get", "list", "export"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      pipelineId: z.string().optional().describe("Pipeline ID"),
      title: z.string().optional().describe("Spec title (for start)"),
      description: z.string().optional().describe("Description (for start)"),
      role: z.enum(["gatherer", "researcher", "writer", "critic"]).optional().describe("Role (for phase, complete)"),
      output: z.string().optional().describe("Phase output (for complete)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "start":
        result = await startSpecPipeline({
          repoPath: input.repoPath,
          title: input.title,
          description: input.description,
          commitMode,
        });
        break;
      case "phase":
        result = await startSpecPhase({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
          role: input.role,
          commitMode,
        });
        break;
      case "complete":
        result = await completeSpecPhase({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
          role: input.role,
          output: input.output,
          commitMode,
        });
        break;
      case "get":
        result = await getSpecPipeline({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
        });
        break;
      case "list":
        result = await listSpecPipelines({ repoPath: input.repoPath });
        break;
      case "export":
        result = await exportSpecAsMarkdown({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 26. swarm_qa - QA loop (reviewer → fixer → loop)
 */
export const swarmQaTool = [
  "swarm_qa",
  {
    title: "Swarm QA",
    description: "QA loop for iterative review and fix. Actions: start, iterate, fix, get, list, suggest, report",
    inputSchema: z.object({
      action: z.enum(["start", "iterate", "fix", "get", "list", "suggest", "report"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      loopId: z.string().optional().describe("QA loop ID"),
      taskId: z.string().optional().describe("Task ID (for start)"),
      issues: z.array(z.string()).optional().describe("Issues found (for iterate)"),
      fixDescription: z.string().optional().describe("Fix description (for fix)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "start":
        result = await startQALoop({
          repoPath: input.repoPath,
          taskId: input.taskId,
          commitMode,
        });
        break;
      case "iterate":
        result = await runQAIteration({
          repoPath: input.repoPath,
          loopId: input.loopId,
          issues: input.issues,
          commitMode,
        });
        break;
      case "fix":
        result = await logQAFix({
          repoPath: input.repoPath,
          loopId: input.loopId,
          fixDescription: input.fixDescription,
          commitMode,
        });
        break;
      case "get":
        result = await getQALoop({
          repoPath: input.repoPath,
          loopId: input.loopId,
        });
        break;
      case "list":
        result = await listQALoops({ repoPath: input.repoPath });
        break;
      case "suggest":
        result = await getQAFixSuggestions({
          repoPath: input.repoPath,
          loopId: input.loopId,
        });
        break;
      case "report":
        result = await generateQAReport({
          repoPath: input.repoPath,
          loopId: input.loopId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 27. swarm_hooks - Guard hooks (pre-commit/pre-push)
 */
export const swarmHooksTool = [
  "swarm_hooks",
  {
    title: "Swarm Hooks",
    description: "Guard hooks for pre-commit/pre-push safety. Actions: install, uninstall, run, config, update, list",
    inputSchema: z.object({
      action: z.enum(["install", "uninstall", "run", "config", "update", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      hookType: z.enum(["pre-commit", "pre-push"]).optional().describe("Hook type"),
      enabled: z.boolean().optional().describe("Enable/disable hook"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "install":
        result = await installGuardHooks({
          repoPath: input.repoPath,
          commitMode,
        });
        break;
      case "uninstall":
        result = await uninstallGuardHooks({
          repoPath: input.repoPath,
          commitMode,
        });
        break;
      case "run":
        result = await runGuardHooks({
          repoPath: input.repoPath,
          hookType: input.hookType,
        });
        break;
      case "config":
        result = await getGuardConfig({ repoPath: input.repoPath });
        break;
      case "update":
        result = await updateGuardHook({
          repoPath: input.repoPath,
          hookType: input.hookType,
          enabled: input.enabled,
          commitMode,
        });
        break;
      case "list":
        result = await listGuardHooks({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 28. swarm_screenshot - Screenshot sharing
 */
export const swarmScreenshotTool = [
  "swarm_screenshot",
  {
    title: "Swarm Screenshot",
    description: "Screenshot sharing between agents. Actions: share, list",
    inputSchema: z.object({
      action: z.enum(["share", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      imagePath: z.string().optional().describe("Path to screenshot image (for share)"),
      description: z.string().optional().describe("Screenshot description (for share)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "share":
        result = await shareScreenshot({
          repoPath: input.repoPath,
          agentName: input.agentName,
          imagePath: input.imagePath,
          description: input.description,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await listScreenshots({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 29. swarm_dependency - Dependency synchronization
 */
export const swarmDependencyTool = [
  "swarm_dependency",
  {
    title: "Swarm Dependency",
    description: "Dependency change signaling and sync. Actions: signal, sync",
    inputSchema: z.object({
      action: z.enum(["signal", "sync"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      packageManager: z.string().optional().describe("Package manager (npm, yarn, pnpm)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "signal":
        result = await signalDependencyChange({
          repoPath: input.repoPath,
          agentName: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "sync":
        result = await syncDependencies({
          repoPath: input.repoPath,
          packageManager: input.packageManager,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 30. swarm_platform - Cross-platform checks
 */
export const swarmPlatformTool = [
  "swarm_platform",
  {
    title: "Swarm Platform",
    description: "Cross-platform compatibility checks. Actions: request, respond, list",
    inputSchema: z.object({
      action: z.enum(["request", "respond", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      checkId: z.string().optional().describe("Check ID (for respond)"),
      platform: z.string().optional().describe("Platform to check (for request)"),
      filePath: z.string().optional().describe("File to check (for request)"),
      agentName: z.string().optional().describe("Agent name"),
      result: z.string().optional().describe("Check result (for respond)"),
      passed: z.boolean().optional().describe("Check passed (for respond)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "request":
        result = await requestPlatformCheck({
          repoPath: input.repoPath,
          platform: input.platform,
          filePath: input.filePath,
          requestingAgent: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "respond":
        result = await respondToPlatformCheck({
          repoPath: input.repoPath,
          checkId: input.checkId,
          responderAgent: input.agentName,
          result: input.result,
          passed: input.passed,
          commitMode: input.commitMode || "push",
        });
        break;
      case "list":
        result = await getPendingPlatformChecks({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 31. swarm_immune - Immune system (CI alerts, local tests)
 */
export const swarmImmuneTool = [
  "swarm_immune",
  {
    title: "Swarm Immune",
    description: "Immune system for CI alerts and tests. Actions: alert, resolve, status, test, patrol",
    inputSchema: z.object({
      action: z.enum(["alert", "resolve", "status", "test", "patrol"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      alertId: z.string().optional().describe("Alert ID (for resolve)"),
      errorMessage: z.string().optional().describe("Error message (for alert)"),
      source: z.string().optional().describe("Alert source (for alert)"),
      agentName: z.string().optional().describe("Agent name"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "alert":
        result = await reportCiAlert({
          repoPath: input.repoPath,
          errorMessage: input.errorMessage,
          source: input.source,
          commitMode: input.commitMode || "push",
        });
        break;
      case "resolve":
        result = await resolveAlert({
          repoPath: input.repoPath,
          alertId: input.alertId,
          resolvedBy: input.agentName,
          commitMode: input.commitMode || "push",
        });
        break;
      case "status":
        result = await getImmuneStatus({ repoPath: input.repoPath });
        break;
      case "test":
        result = await runLocalTests({ repoPath: input.repoPath });
        break;
      case "patrol":
        result = await patrolMode({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 32. swarm_context - Context compression
 */
export const swarmContextTool = [
  "swarm_context",
  {
    title: "Swarm Context",
    description: "Context size estimation and compression. Actions: estimate, compress, compress_many, stats",
    inputSchema: z.object({
      action: z.enum(["estimate", "compress", "compress_many", "stats"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      text: z.string().optional().describe("Text to estimate/compress"),
      briefingId: z.string().optional().describe("Briefing ID (for compress)"),
      briefingIds: z.array(z.string()).optional().describe("Briefing IDs (for compress_many)"),
      targetTokens: z.number().optional().describe("Target token count"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "estimate":
        result = await estimateContextSize({
          text: input.text,
        });
        break;
      case "compress":
        result = await compressBriefing({
          repoPath: input.repoPath,
          briefingId: input.briefingId,
          targetTokens: input.targetTokens,
        });
        break;
      case "compress_many":
        result = await compressMultipleBriefings({
          repoPath: input.repoPath,
          briefingIds: input.briefingIds,
          targetTokens: input.targetTokens,
        });
        break;
      case "stats":
        result = await getCompressionStats({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 33. swarm_regression - Regression detection
 */
export const swarmRegressionTool = [
  "swarm_regression",
  {
    title: "Swarm Regression",
    description: "Regression detection with baselines. Actions: baseline, check, list, resolve, baselines",
    inputSchema: z.object({
      action: z.enum(["baseline", "check", "list", "resolve", "baselines"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      metricName: z.string().optional().describe("Metric name"),
      value: z.number().optional().describe("Metric value"),
      regressionId: z.string().optional().describe("Regression ID (for resolve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "baseline":
        result = await saveBaseline({
          repoPath: input.repoPath,
          metricName: input.metricName,
          value: input.value,
          commitMode,
        });
        break;
      case "check":
        result = await checkRegression({
          repoPath: input.repoPath,
          metricName: input.metricName,
          value: input.value,
        });
        break;
      case "list":
        result = await listRegressions({ repoPath: input.repoPath });
        break;
      case "resolve":
        result = await resolveRegression({
          repoPath: input.repoPath,
          regressionId: input.regressionId,
          commitMode,
        });
        break;
      case "baselines":
        result = await listBaselines({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 34. swarm_expertise - Agent expertise tracking
 */
export const swarmExpertiseTool = [
  "swarm_expertise",
  {
    title: "Swarm Expertise",
    description: "Agent expertise and specialization tracking. Actions: track, suggest, record, experts, list",
    inputSchema: z.object({
      action: z.enum(["track", "suggest", "record", "experts", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name"),
      domain: z.string().optional().describe("Domain/skill area"),
      taskId: z.string().optional().describe("Task ID (for suggest)"),
      filePath: z.string().optional().describe("File path (for record)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "track":
        result = await trackExpertise({
          repoPath: input.repoPath,
          agentName: input.agentName,
          domain: input.domain,
          commitMode,
        });
        break;
      case "suggest":
        result = await suggestAgentAdvanced({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      case "record":
        result = await recordAgentEdit({
          repoPath: input.repoPath,
          agentName: input.agentName,
          filePath: input.filePath,
          commitMode,
        });
        break;
      case "experts":
        result = await getTopExperts({
          repoPath: input.repoPath,
          domain: input.domain,
        });
        break;
      case "list":
        result = await listAllAgentExpertise({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 35. swarm_conflict - Conflict prediction
 */
export const swarmConflictTool = [
  "swarm_conflict",
  {
    title: "Swarm Conflict",
    description: "Conflict prediction and history. Actions: predict, analyze, hotspots, record",
    inputSchema: z.object({
      action: z.enum(["predict", "analyze", "hotspots", "record"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      filePath: z.string().optional().describe("File path"),
      agentName: z.string().optional().describe("Agent name (for record)"),
      conflictType: z.string().optional().describe("Conflict type (for record)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "predict":
        result = await predictConflicts({
          repoPath: input.repoPath,
          filePath: input.filePath,
        });
        break;
      case "analyze":
        result = await analyzeConflictHistory({ repoPath: input.repoPath });
        break;
      case "hotspots":
        result = await getConflictHotspots({ repoPath: input.repoPath });
        break;
      case "record":
        result = await recordConflictEvent({
          repoPath: input.repoPath,
          filePath: input.filePath,
          agentName: input.agentName,
          conflictType: input.conflictType,
          commitMode: input.commitMode || "push",
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 36. swarm_timeline - Timeline generation
 */
export const swarmTimelineTool = [
  "swarm_timeline",
  {
    title: "Swarm Timeline",
    description: "Timeline generation and visualization. Actions: generate, visualize",
    inputSchema: z.object({
      action: z.enum(["generate", "visualize"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      format: z.enum(["json", "mermaid", "ascii"]).optional().describe("Output format"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    
    switch (input.action) {
      case "generate":
        result = await generateTimeline({
          repoPath: input.repoPath,
          taskId: input.taskId,
        });
        break;
      case "visualize":
        result = await getTimelineVisualization({
          repoPath: input.repoPath,
          taskId: input.taskId,
          format: input.format,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 37. swarm_docs - Auto documentation
 */
export const swarmDocsTool = [
  "swarm_docs",
  {
    title: "Swarm Docs",
    description: "Auto documentation generation. Actions: generate, task_docs, list, get",
    inputSchema: z.object({
      action: z.enum(["generate", "task_docs", "list", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      docId: z.string().optional().describe("Documentation ID (for get)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "generate":
        result = await autoGenerateDocs({
          repoPath: input.repoPath,
          commitMode,
        });
        break;
      case "task_docs":
        result = await generateTaskDocumentation({
          repoPath: input.repoPath,
          taskId: input.taskId,
          commitMode,
        });
        break;
      case "list":
        result = await listDocumentation({ repoPath: input.repoPath });
        break;
      case "get":
        result = await getDocumentation({
          repoPath: input.repoPath,
          docId: input.docId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 38. swarm_advice - Collective advice
 */
export const swarmAdviceTool = [
  "swarm_advice",
  {
    title: "Swarm Advice",
    description: "Collective advice requests. Actions: request, provide, list",
    inputSchema: z.object({
      action: z.enum(["request", "provide", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      adviceId: z.string().optional().describe("Advice request ID"),
      question: z.string().optional().describe("Question (for request)"),
      agentName: z.string().optional().describe("Agent name"),
      advice: z.string().optional().describe("Advice text (for provide)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "request":
        result = await requestCollectiveAdvice({
          repoPath: input.repoPath,
          question: input.question,
          requestingAgent: input.agentName,
          commitMode,
        });
        break;
      case "provide":
        result = await provideAdvice({
          repoPath: input.repoPath,
          adviceId: input.adviceId,
          advisorAgent: input.agentName,
          advice: input.advice,
          commitMode,
        });
        break;
      case "list":
        result = await getOpenAdviceRequests({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 39. swarm_preemption - Urgent preemption
 */
export const swarmPreemptionTool = [
  "swarm_preemption",
  {
    title: "Swarm Preemption",
    description: "Urgent task preemption. Actions: trigger, resolve, active",
    inputSchema: z.object({
      action: z.enum(["trigger", "resolve", "active"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      urgentId: z.string().optional().describe("Urgent preemption ID"),
      reason: z.string().optional().describe("Preemption reason"),
      agentName: z.string().optional().describe("Agent name"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "trigger":
        result = await triggerUrgentPreemption({
          repoPath: input.repoPath,
          reason: input.reason,
          triggeredBy: input.agentName,
          commitMode,
        });
        break;
      case "resolve":
        result = await resolveUrgent({
          repoPath: input.repoPath,
          urgentId: input.urgentId,
          resolvedBy: input.agentName,
          commitMode,
        });
        break;
      case "active":
        result = await getActiveUrgent({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 40. swarm_clusters - Tool clustering
 */
export const swarmClustersTool = [
  "swarm_clusters",
  {
    title: "Swarm Clusters",
    description: "Tool clustering for context optimization. Actions: init, list, tools, find, add, create, summary",
    inputSchema: z.object({
      action: z.enum(["init", "list", "tools", "find", "add", "create", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      clusterName: z.string().optional().describe("Cluster name"),
      toolName: z.string().optional().describe("Tool name"),
      taskDescription: z.string().optional().describe("Task description (for find)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "init":
        result = await initToolClusters({
          repoPath: input.repoPath,
          commitMode,
        });
        break;
      case "list":
        result = await listToolClusters({ repoPath: input.repoPath });
        break;
      case "tools":
        result = await getClusterTools({
          repoPath: input.repoPath,
          clusterName: input.clusterName,
        });
        break;
      case "find":
        result = await findToolCluster({
          repoPath: input.repoPath,
          taskDescription: input.taskDescription,
        });
        break;
      case "add":
        result = await addToolToCluster({
          repoPath: input.repoPath,
          clusterName: input.clusterName,
          toolName: input.toolName,
          commitMode,
        });
        break;
      case "create":
        result = await createToolCluster({
          repoPath: input.repoPath,
          clusterName: input.clusterName,
          commitMode,
        });
        break;
      case "summary":
        result = await getToolClusterSummary({ repoPath: input.repoPath });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

/**
 * 41. swarm_session - Session recording
 */
export const swarmSessionTool = [
  "swarm_session",
  {
    title: "Swarm Session",
    description: "Session recording and replay. Actions: start, log, stop, list, replay",
    inputSchema: z.object({
      action: z.enum(["start", "log", "stop", "list", "replay"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      sessionId: z.string().optional().describe("Session ID"),
      agentName: z.string().optional().describe("Agent name"),
      actionType: z.string().optional().describe("Action type (for log)"),
      details: z.string().optional().describe("Action details (for log)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    let result: any;
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "start":
        result = await startSessionRecording({
          repoPath: input.repoPath,
          agentName: input.agentName,
          commitMode,
        });
        break;
      case "log":
        result = await logSessionAction({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          actionType: input.actionType,
          details: input.details,
          commitMode,
        });
        break;
      case "stop":
        result = await stopSessionRecording({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          commitMode,
        });
        break;
      case "list":
        result = await listSessionRecordings({ repoPath: input.repoPath });
        break;
      case "replay":
        result = await replaySession({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
        });
        break;
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

// ============ EXPORT ALL SMART TOOLS ============

export const allSmartTools = [
  swarmAgentTool,
  swarmTaskTool,
  swarmFileTool,
  swarmGitTool,
  swarmWorktreeTool,
  swarmCompanionTool,
  swarmControlTool,
  swarmChatTool,
  swarmReviewTool,
  swarmVotingTool,
  swarmAuctionTool,
  swarmMcpTool,
  swarmOrchestratorTool,
  swarmMessageTool,
  swarmBriefingTool,
  swarmPulseTool,
  swarmKnowledgeTool,
  swarmSnapshotTool,
  swarmHealthTool,
  swarmQualityTool,
  swarmCostTool,
  swarmBrainstormTool,
  swarmPlanTool,
  swarmDebugTool,
  swarmSpecTool,
  swarmQaTool,
  swarmHooksTool,
  // New Smart Tools (28-41)
  swarmScreenshotTool,
  swarmDependencyTool,
  swarmPlatformTool,
  swarmImmuneTool,
  swarmContextTool,
  swarmRegressionTool,
  swarmExpertiseTool,
  swarmConflictTool,
  swarmTimelineTool,
  swarmDocsTool,
  swarmAdviceTool,
  swarmPreemptionTool,
  swarmClustersTool,
  swarmSessionTool,
];
